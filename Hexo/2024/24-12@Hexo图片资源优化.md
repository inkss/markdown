---
title: Hexo 图片资源优化
showPostHeadimg: false
toc: true
indent: true
tag:
  - Hexo
  - webp
  - avif
  - 压缩
categories: 教程
description: '静态博客就是好，所有资源都能提前预处理：图片压缩、转 webp, avif 等等。'
date: '2024-12-31 23:43'
updated: '2024-12-31 23:43'
copyright:
  type: cc
headimg: ../../img/article/24-11@米家自动化极客版使用指北/Hexo博客封面.png
abbrlink: 3659af8e
---

一个老生常谈的话题了，关于博客类资源的优化，包括但不限于图片压缩，使用更优秀的文件格式，浏览器兼容处理。这里重新整理归纳处理下，以前本站做过基于 gulp 的图片压缩和 webp 图片转换使用，后来由于效果不佳转而使用腾讯云 CDN 的数据万象服务了。

现在嘛，消费降级，还是减少对付费服务的依赖吧。同时在刷博客时看到了 Heo 的 [实现全站图片使用avif格式，替代臃肿的webp教程](https://blog.zhheo.com/p/6a933575.html) ，新的图片格式真是如雨后春笋层出不穷呀。Whatever，那么重新加上本地处理的能力，除 webp 外再带上 avif。

## 一、图片压缩转换

两个目标：原始图片的压缩，原始图片的 webp, avif 格式转换。考虑到 Hexo 基于 Node 引擎，那么翻翻前端库，我们决定使用 [lovell/sharp: High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, AVIF and TIFF images. Uses the libvips library.](https://github.com/lovell/sharp)

刚好，这个库既能压缩，又能转图片格式，还可以用 Node 运行，不二之选，完美至极。

**处理思路：**

- 对原图进行压缩，避免二次压缩，也避免压缩后文件体积反而增大的奇葩事儿；
- 只转换指定格式的图片，一般来讲，只需处理 `jpg`, `jpeg`, `png`, `bmp` 这些格式即可；
- 如果待处理的目录中已经存在了转换后的 webp, avif 文件就不转换啦；
- 如果待处理的目录中存在转换后的 webp, avif 文件，但不存在同名其它格式文件，视作原图缺失。

{% folding message yellow, sharp.js %}

```js 记得安装 sharp 库：npm i sharp
const sharp = require('sharp');
const fs = require('fs');
const path = require('path');

// 从命令行参数获取输入文件夹
const inputFolder = path.resolve(process.cwd(), process.argv[2] || './source/image');

// 定义想转换和压缩的图片格式
const includeFormats = ['.png', '.jpg', '.jpeg', '.bmp'];

// 定义计数器
let imageCount = 0;

// 开始计时
console.time('Image Conversion and Compression Time');

// 删除丢失原图的转换图片
const removeOrphanedConvertedImages = (folder) => {
  const files = fs.readdirSync(folder).sort();
  const deleteList = new Set();

  files.forEach(file => {
    const inputFilePath = path.join(folder, file);
    const stats = fs.statSync(inputFilePath);

    if (stats.isDirectory()) {
      removeOrphanedConvertedImages(inputFilePath);
    } else if (stats.isFile()) {
      const baseName = path.basename(inputFilePath, path.extname(inputFilePath));
      const dirName = path.dirname(inputFilePath);

      const webpPath = path.join(dirName, baseName + '.webp');
      const avifPath = path.join(dirName, baseName + '.avif');

      if (fs.existsSync(webpPath) && fs.existsSync(avifPath) && !deleteList.has(webpPath) && !deleteList.has(avifPath)) {
        const originalExists = files.some(f => {
          const ext = path.extname(f).toLowerCase();
          return f.startsWith(baseName) && includeFormats.includes(ext);
        });

        if (!originalExists) {
          deleteList.add(webpPath);
          deleteList.add(avifPath);
          console.log(`Marked for deletion: ${webpPath} and ${avifPath}`);
        }
      }
    }
  });

  // 删除待删除列表中的文件
  deleteList.forEach(file => {
    fs.unlinkSync(file);
    console.log(`Deleted orphaned converted image: ${file}`);
  });
};

// 压缩图片的函数
const compressImage = async (inputFilePath) => {
  const ext = path.extname(inputFilePath).toLowerCase();
  const outputWebPPath = inputFilePath.replace(/\.[^/.]+$/, '.webp');
  const outputAvifPath = inputFilePath.replace(/\.[^/.]+$/, '.avif');

  if (fs.existsSync(outputWebPPath) && fs.existsSync(outputAvifPath)) {
    //console.log(`Skipping compression and conversion for ${inputFilePath}, converted images already exist`);
    return;
  }

  try {
    let buffer;

    if (ext === '.png') {
      buffer = await sharp(inputFilePath).png({ compressionLevel: 3, adaptiveFiltering: true }).toBuffer();
    } else if (ext === '.jpg' || ext === '.jpeg') {
      buffer = await sharp(inputFilePath).jpeg({ quality: 80 }).toBuffer();
    } else if (ext === '.bmp') {
      buffer = await sharp(inputFilePath).toFormat('bmp').toBuffer();
    } else if (ext === '.webp') {
      buffer = await sharp(inputFilePath).webp({ quality: 80, lossless: true }).toBuffer();
    }

    const originalSize = fs.statSync(inputFilePath).size;
    const compressedSize = buffer.length;

    if (compressedSize < originalSize) {
      fs.writeFileSync(inputFilePath, buffer);
      console.log(`Compressed ${inputFilePath}, original size: ${originalSize} bytes, compressed size: ${compressedSize} bytes`);
    } else {
      //console.log(`Skipping compression for ${inputFilePath}, compressed size: ${compressedSize} bytes is not smaller than original size: ${originalSize} bytes`);
    }
  } catch (err) {
    console.error(`Error compressing ${inputFilePath}:`, err);
  }

  convertImage(inputFilePath);  // 压缩完成后进行转换
};


// 转换图片的函数
const convertImage = (inputFilePath) => {
  const ext = path.extname(inputFilePath).toLowerCase();
  const outputWebPPath = inputFilePath.replace(/\.[^/.]+$/, '.webp');
  const outputAvifPath = inputFilePath.replace(/\.[^/.]+$/, '.avif');

  // 检查输入文件是否已经是 WebP 或 AVIF 格式
  if (ext === '.webp' || ext === '.avif') {
    console.log(`Skipping conversion for ${inputFilePath}, already in target format`);
    return;
  }

  // 检查输出文件是否已经存在
  if (!fs.existsSync(outputWebPPath) || !fs.existsSync(outputAvifPath)) {
    // 将图片转换为 WebP 格式
    sharp(inputFilePath)
      .webp({ quality: 80 })
      .toFile(outputWebPPath)
      .then(() => {
        console.log(`Converted ${inputFilePath} to ${outputWebPPath}`);
        imageCount++;
      })
      .catch(err => console.error(`Error converting ${inputFilePath} to WebP:`, err));

    // 将图片转换为 AVIF 格式
    sharp(inputFilePath)
      .avif({ quality: 50 })
      .toFile(outputAvifPath)
      .then(() => {
        console.log(`Converted ${inputFilePath} to ${outputAvifPath}`);
        imageCount++;
      })
      .catch(err => console.error(`Error converting ${inputFilePath} to AVIF:`, err));
  } else {
    //console.log(`Skipping conversion for ${inputFilePath}, converted images already exist`);
  }
};

// 递归遍历文件夹处理图片
const processFolder = (folder) => {
  fs.readdirSync(folder).forEach(file => {
    const inputFilePath = path.join(folder, file);
    const stats = fs.statSync(inputFilePath);

    if (stats.isDirectory()) {
      processFolder(inputFilePath);
    } else if (stats.isFile() && includeFormats.includes(path.extname(inputFilePath).toLowerCase())) {
      compressImage(inputFilePath);
    }
  });
};

// 处理完成后的日志输出
const logResult = () => {
  console.timeEnd('Image Conversion and Compression Time');
  console.log(`Total images converted and compressed: ${imageCount}`);
};

// 删除丢失原图的转换图片
removeOrphanedConvertedImages(inputFolder);

// 处理文件夹
processFolder(inputFolder);

// 在所有转换和压缩完成后输出结果日志
process.on('exit', logResult);
```

{% endfolding %}

假设这个脚本放在 `.tools/sharp.js` 中，同时你的所有图片文件都在 `./source/image` 目录下，只需要在你的自动化部署代码中添加如下内容便可以自动转换图片：

```sh
node ./tools/sharps.js
```

转换后的文件放在同路径下，所以事实上你仓库体积会膨胀那么一丢丢。如果介意空间占用，却不介意部署时的时间，可以在 Hexo 生成网页后、部署到服务器前对 `./public/image` 进行处理，既：

```sh
node ./tools/sharps.js ./public/image
```

## 二、图片资源调用

只关心 Chromium 系的兼容性，webp 32 支持，avif 85 支持。avif 的兼容性有那么一点点欠佳。传统技能，使用 picture 标签提供回退图像（Chromium 38）。

> **HTML `<picture>` 元素** 通过包含零或多个 [source](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source) 元素和一个 img 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 `<source>` 元素，如果没有匹配的，就选择 `<img>` 元素的 `src` 属性中的 URL。然后，所选图像呈现在 `<img>` 元素占据的空间中。

也就是对于常规 `<img>` 标签，替换成形式：

```html
<picture>
  <source srcset="diagram.webp" type="image/webp" />
  <source srcset="diagram.avif" type="image/avif" />
  <img src="diagram.png" alt="数据通道示意图" />
</picture>
```

![hexo](../../img/article/24-12@Hexo图片资源优化/hexo.gif)

![hexo](../../img/article/24-12@Hexo图片资源优化/hexo.webp)

![hexo1](../../img/article/24-12@Hexo图片资源优化/hexo1.webp)
