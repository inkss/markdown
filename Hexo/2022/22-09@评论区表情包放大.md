---
title: 评论区表情包放大
seo_title: 评论区表情包放大
toc: true
indent: true
tag:
  - Artalk
categories: 教程
description: 为评论区的表情包添加一个放大弹出层，解决显示过小不清晰的问题。
date: '2022-10-23 22:00'
updated: '2024-12-29 23:05'
copyright:
  type: adapt
  ref:
    title: 《评论表情包放大功能，超实用》
    url: https://blog.leonus.cn/2022/owo-big.html
abbrlink: 17e0ee16
headimg: ../../img/article/22-09@评论区表情包放大/image-20220918152524215.png
showPostHeadimg: true
---

一般情况下评论区的表情宽和高是固定显示，所以有些尺寸相对较大的表情包是缩放显示的，模糊不说还可能导致误解表情包的含义，本教程为表情图案添加了一个简单的放大弹出层，非常的实用。

## 教程

其实实现的原理很简单，就是创建一个盒子，将表情包的内容放在盒子里面，再读取图片的 Alt 等描述属性现在在盒子中，最后控制盒子位置和显示隐藏即可。而在表情包放大逻辑方面，基本属性为：2 倍放大显示，最大显示宽高为 200px（如若超过，按比例对应缩小）。

### 实现

具体到实现，就是利用 `observer` 观察评论区元素新增的节点，根据相关选择器过滤出含表情包的节点，添加对应的事件，以 Artalk 评论系统为例处理到的选择器为：

```js
/**
 * 放大项：
 * ① 表情包选择
 * ② 评论内容
 * ③ 预览窗（只有一张图）
 * ④ 预览窗（任意）
 */
function shouldEnlarge(element: HTMLElement): boolean {
  return element.classList?.contains('atk-grp')
    || element.classList?.contains('atk-comment-wrap')
    || !!element.attributes?.['atk-emoticon']
    || !!element.querySelector?.('img[atk-emoticon]');
}
```

### 代码

{% folding cyan, JavaScript %}

```js 以下代码适用于 Artalk，需要自行调用。
showOwoBig(target: Node) {
  const ratio = 2;
  const maxLength = 200;
  const body = document.querySelector('body') || document.createElement('body');
  let div = document.querySelector('#owo-big') as HTMLElement;

  if (!div) {
    div = document.createElement('div');
    div.id = 'owo-big';
    body.appendChild(div);
  }

  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        const element = node as HTMLElement;

        if (shouldEnlarge(element)) {
          setupHoverEffects(element);
        }
      });
    });
  });

  observer.observe(target, { subtree: true, childList: true });

  function shouldEnlarge(element: HTMLElement): boolean {
    return element.classList?.contains('atk-grp')
      || element.classList?.contains('atk-comment-wrap')
      || !!element.attributes?.['atk-emoticon']
      || !!element.querySelector?.('img[atk-emoticon]');
  }

  function setupHoverEffects(element: HTMLElement) {
    let flag = true;
    let owoTime: number;

    element.addEventListener('mouseover', (e: MouseEvent) => {
      const imgElement = e.target as HTMLImageElement;
      
      if (flag && imgElement.tagName === 'IMG' && imgElement.attributes['atk-emoticon']) {
        flag = false;
        owoTime = window.setTimeout(() => {
          const alt = imgElement.getAttribute("notitle") === "true" ? '' : imgElement.alt || '';
          const { clientHeight, clientWidth, naturalHeight, naturalWidth } = imgElement;
          
          if (clientHeight <= maxLength && clientWidth <= maxLength) {
            const { tempWidth, tempHeight } = calculateSize(clientHeight, clientWidth, naturalHeight, naturalWidth);
            const { top, left } = calculatePosition(e, tempWidth, clientWidth, body);

            let adjustedTempHeight = tempHeight;
            if (alt !== '') adjustedTempHeight += 10;

            div.style.cssText = `display:block;height:${adjustedTempHeight + 34}px;width:${tempWidth + 34}px;left:${left}px;top:${top}px;`;
            div.innerHTML = `<img src="${imgElement.src}" onerror="this.classList.add('error')"><p>${alt}</p>`;
          }
        }, 300);
      }
    });

    element.addEventListener('mouseout', () => {
      flag = true;
      div.style.display = 'none';
      clearTimeout(owoTime);
    });
  }

  function calculateSize(clientHeight: number, clientWidth: number, naturalHeight: number, naturalWidth: number): { tempWidth: number, tempHeight: number } {
    const zoomHeight = clientHeight * ratio;
    const zoomWidth = clientWidth * ratio;

    const height = Math.min(naturalHeight, zoomHeight, maxLength, clientHeight);
    const width = Math.min(naturalWidth, zoomWidth, maxLength, clientWidth);
    const aspectRatio = width / height;

    const tempWidth = aspectRatio >= 1 ? Math.min(width, maxLength) : Math.min((width * maxLength) / height, width);
    const tempHeight = aspectRatio < 1 ? Math.min(height, maxLength) : Math.min((height * maxLength) / width, height);

    return { tempWidth, tempHeight };
  }

  function calculatePosition(e: MouseEvent, tempWidth: number, clientWidth: number, bodyElement: HTMLElement): { top: number, left: number } {
    const top = e.clientY - e.offsetY;
    let left = e.clientX - e.offsetX - (tempWidth - clientWidth) / 2;

    left = Math.max(10, Math.min(left, bodyElement.clientWidth - tempWidth - 10));

    return { top, left };
  }
}
```

{% endfolding %}

{% folding cyan, SCSS %}

```scss
#owo-big {
  position: fixed;
  align-items: center;
  background-color: var(--at-color-owo);
  backdrop-filter: saturate(200%) blur(6px);
  border: 1px solid var(--at-color-bg-light);
  border-radius: 12px;
  box-shadow: 0 0 12px 4px rgb(0 0 0 / 5%);
  z-index: 9999;
  display: none;
  transform: translate(0, -105%);
  overflow: hidden;
  animation: owoIn 0.3s cubic-bezier(0.42, 0, 0.3, 1.11);
  padding: 16px;
  user-select: none;

  img {
    width: 100%;
    border-radius: 10px;
  }

  p {
    color: var(--at-color-meta);
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    text-align: center;
    font-size: 12px;
    margin: 0;
  }

  &:has(img.error) {
    display: none !important
  }
}

@keyframes owoIn {
  0% {
    transform: translate(0, -95%);
    opacity: 0;
  }

  100% {
    transform: translate(0, -105%);
    opacity: 1;
  }
}
```

{% endfolding %}
