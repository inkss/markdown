---
title: 自定义右键重构篇
toc: true
indent: true
hiddenTitle: false
tag:
  - 自定义右键菜单
  - 前端开发
  - 网站优化
  - JavaScript
categories: 博客
description: >-
  这篇文章详细介绍了如何通过自定义右键菜单来提升用户体验。文章从需求分析入手，介绍了导航栏和菜单项的分类及功能，详细讲解了配置文件的设置和页面绘制的流程。通过阅读这篇文章，读者可以学习到如何设计和实现一个高效、优雅的自定义右键菜单，提升网站的交互性和用户体验。
date: '2025-01-21 01:20'
updated: '2025-01-21 15:00'
background: ../../img/article/21-07@自动化博客部署/wallhaven-48o37j.avif
headimg: ../../img/article/25-01@自定义右键重构篇/Hexo博客封面.png
abbrlink: 4f48cb48
references:
  - title: 原生 JS 的右键菜单实现
    url: https://inkss.cn/post/3717f151
---

是的，自定义右键菜单再次尝试重构了。上一次重构是在 2022 年，但最近在尝试修改时发现，目前实现逻辑过于复杂且不够优雅，同时由于缺乏合适的注释，花了不少时间才理清调用关系，{% emoji kulou %} 惭愧。

<!-- more -->

因此，决定推倒重来，重新设计。

## 一、需求分析

菜单类型分为两类：导航栏和菜单项。导航栏：位于顶部（类似火狐浏览器的右键菜单），采用横向布局，仅显示图标。菜单项：采用竖向布局，显示图标和菜单名称，对应一般的普通菜单。

功能上也可分为两类：链接型菜单和事件型菜单。链接型菜单：记录网址和链接类型，例如：回到首页、查看留言板页面。事件型菜单：需要执行函数的菜单项，例如：复制文本、打印页面。

详细分析见下面的思维导图：

![右键菜单思维导图](../../img/article/25-01@自定义右键重构篇/右键菜单.svg)

### 1.1 配置文件

```yaml Hexo 配置文件示例
rightmenus:
  enable: true
  options:
    navigation: true # 是否显示导航栏组件
    maxMenuItems: 12 # 最大菜单显示数量
  navigation: 
    - { menuItem }
  menuList:
    - { menuItem }
```

`navigation` 和 `menuList` 字段的定义顺序决定了菜单加载的显示顺序。在 `options` 中，`navigation` 控制是否显示导航栏组件；当满足条件的菜单项数量超过 `maxMenuItems` 时，隐藏所有链接型菜单。在 `menuList` 菜单项中，如果相邻菜单项的 `displayCondition` 值不同，则自动添加分割线。也可以手动定义菜单分割线，此时自动判断会关闭，并在定义的位置添加分割线。

```code 菜单分割线定义方式
hr, {}, {id: 'hr'}
```

对于 eventName 和 displayCondition 的值，右键菜单函数会预设一些事件和判断函数。在进行菜单项判断或点击事件触发时，首先会检查右键菜单函数中是否存在相应的实现。如果不存在，则会在 window 上尝试调用，同时传递 menuItem[^1]、event 和 pointevent 值。具体的调用方式如下：

[^1]: 注：此处 `menuItem` 对象未包含数据组成中的 `name, icon` 属性，但额外提供两个属性：
    ```js
    {
      isHrElement: '是否为菜单分割项',
      menuContentElement: '菜单项所对应 DOM 节点'
    }
    ```

```js eventName
/**
 * 在 window 上尝试按照 eventName 值调用函数
 * 
 * @param {Object} menuItem 菜单项
 * @param {Event} event 点击事件
 * @param {PointerEvent} pointevent 右键事件
 */
window[eventName](menuItem, event, pointevent)()
```

```js displayCondition
/**
 * 在 window 上尝试按照 displayCondition 值调用函数
 * 
 * @param {Object} menuItem 菜单项
 * @param {PointerEvent} pointevent 右键事件
 * @returns {boolean} - true/false 是否允许当前菜单项显示
 */
window[displayCondition](menuItem, pointevent)()
```

该调用支持简单的点分链式调用、参数传递和文本替换。详细的实现逻辑请见下文。

```yaml 使用示例
- { eventName: 'readMode' } # 内部事件：切换阅读模式
- { eventName: 'window.location.reload' }  # 刷新页面
- { eventName: 'volantis.dark.toggle' } # 切换深色模式
- { eventName: 'window.open(linkAddress)' } # 新标签页打开链接
- { eventName: 'OpenSearch(selectedText)' } # 打开搜索页面，并传递当前选中文本
- { eventName: 'window.open("https://www.bing.com/search?q=##selectedText##")' } # 必应搜索
```

由于传递参数的数量不定，外部函数如有需要，建议使用 `...args` 接收参数。

```js 程序的实际调用方式
// context: 执行函数名
// functionArgs: eventName 定义时的内部已有参数
// args: menuItem, (event), pointEvent
context.apply(parentContext, functionArgs.concat(args));
```

### 1.2 页面绘制

menuItem 中的属性将以 `data-xxxx` 格式写入到菜单项的 HTML 元素上。

```html 例外属性： linkTarget ➡ target, link ➡ href
<% if(item.link === undefined) { %>
  <li class="menuLoad-Content">
    <span class="vlts-menu" data-id="<%- item.id %>" data-event-name="<%= item.eventName %>"
      data-display-condition="<%- item.displayCondition %>">
      <i class="<%- item.icon %>"></i>
      <%- item.name %>
    </span>
  </li>
<% } else { %>
  <% if(!item.linkTarget) item.linkTarget = '_self' %>
  <li class="menuLoad-Content">
    <a class="vlts-menu" data-id="<%- item.id %>" href="<%- item.link %>" 
    target="<%- item.linkTarget %>" data-display-condition="<%- item.displayCondition %>">
      <i class="<%- item.icon %>"></i>
      <%- item.name %>
    </a>
  </li>
<% } %>
```

## 二、处理流程

大致处理流程如下：

👐 使用右键选择器在页面中找到 HTML 元素。

🙌 如果找到，则读取所有导航栏和菜单项**赋值**存储。

🤲 覆盖浏览器默认的右键菜单，**绘制**菜单项并显示自定义右键菜单。

🙏 为右键菜单点击事件添加事件委托，触发相应**事件**。

🤝 Pjax 兼容**回调**。

## 三、功能实现

综上，完整的实现内容请见如下链接文件：

{% link source/js/plugins/rightMenus.js, https://github.com/inkss/volantis/blob/clean/source/js/plugins/rightMenus.js %}

## 四、附录内容

诸如阅读模式和打印模式的功能设计，可以通过修改页面元素样式来实现。例如，在打印网页时，可以通过媒体查询 `media="print"` 引入专用于打印的样式文件。

```html
<link rel="stylesheet" href="/css/print.css" media="print">
```

可以在开发者工具的样式编辑器中，开启模拟 CSS 媒体类型的功能，以调试打印样式。

![开发者工具](../../img/article/25-01@自定义右键重构篇/25-01-21_143930.png)

对于阅读模式，可以通过控制 link 标签的 disabled 属性来决定样式是否生效。

```html
<link id="reading-mode" rel="stylesheet" disabled="true" href="/css/read.css">

<script>
  const readModeStylesheet = document.getElementById('reading-mode');
  readModeStylesheet.disabled = !readModeStylesheet.disabled;
</script>
```
