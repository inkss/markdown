---
title: 自定义右键重构篇
toc: true
indent: true
hiddenTitle: false
tag:
  - 自定义右键菜单
  - 前端开发
  - 网站优化
  - JavaScript
categories: 博客
description: >-
  这篇文章详细介绍了如何通过自定义右键菜单来提升用户体验。文章从需求分析入手，介绍了导航栏和菜单项的分类及功能，详细讲解了配置文件的设置和页面绘制的流程。通过阅读这篇文章，读者可以学习到如何设计和实现一个高效、优雅的自定义右键菜单，提升网站的交互性和用户体验。
date: '2025-01-21 01:20'
updated: '2025-01-21 01:20'
background: ../../img/article/21-07@自动化博客部署/wallhaven-48o37j.avif
headimg: ../../img/article/25-01@自定义右键重构篇/Hexo博客封面.png
abbrlink: 4f48cb48
references:
  - title: 原生 JS 的右键菜单实现
    url: https://inkss.cn/post/3717f151
---

是的，自定义右键菜单再次尝试重构了。上一次重构是在 2022 年，但最近在尝试修改时发现，目前实现逻辑过于复杂且不够优雅，同时由于缺乏合适的注释，花了不少时间才理清调用关系，{% emoji kulou %} 惭愧。

<!-- more -->

因此，决定推倒重来，重新设计。{% emoji family-exam %}

## 一、需求分析

菜单类型分为两类：导航栏和菜单项。导航栏：位于顶部（类似火狐浏览器的右键菜单），采用横向布局，仅显示图标。菜单项：采用竖向布局，显示图标和菜单名称，对应一般的普通菜单。

功能上也可分为两类：链接型菜单和事件型菜单。链接型菜单：记录网址和链接类型，例如：回到首页、查看留言板页面。事件型菜单：需要执行函数的菜单项，例如：复制文本、打印页面。

详细分析见下面的思维导图：

![右键菜单思维导图](../../img/article/25-01@自定义右键重构篇/右键菜单.svg)

### 1.1 配置文件

```yaml Hexo 配置文件示例
rightmenus:
  enable: true
  options:
    navigation: true # 是否显示导航栏组件
    maxMenuItems: 12 # 最大菜单显示数量
  navigation: 
    - { menuItem }
  menuList:
    - { menuItem }
```

`navigation` 和 `menuList` 字段的定义顺序决定了菜单加载的显示顺序。在 `options` 中，`navigation` 控制是否显示导航栏组件；当满足条件的菜单项数量超过 `maxMenuItems` 时，隐藏所有链接型菜单。在 `menuList` 菜单项中，如果相邻菜单项的 `displayCondition` 值不同，则自动添加分割线。也可以手动定义菜单分割线，此时自动判断会关闭，并在定义的位置添加分割线。

```code 菜单分割线定义方式
hr, {}, {id: 'hr'}
```

对于 eventName 和 displayCondition 的值，右键菜单函数会预设一些事件和判断函数。在进行菜单项判断或点击事件触发时，首先会检查右键菜单函数中是否存在相应的实现。如果不存在，则会在 window 上尝试调用，同时传递 menuItem[^1]、event 和 pointevent 值。具体的调用方式如下：

[^1]: 注：此处 `menuItem` 对象未包含数据组成中的 `name, icon` 属性，但额外提供两个属性：
    ```js
    {
      isHrElement: '是否为菜单分割项',
      menuContentElement: '菜单项所对应 DOM 节点'
    }
    ```

```js eventName
/**
 * 在 window 上尝试按照 eventName 值调用函数
 * 
 * @param {Object} menuItem 菜单项
 * @param {Event} event 点击事件
 * @param {PointerEvent} pointevent 右键事件
 */
window[eventName](menuItem, event, pointevent)()
```

```js displayCondition
/**
 * 在 window 上尝试按照 displayCondition 值调用函数
 * 
 * @param {Object} menuItem 菜单项
 * @param {PointerEvent} pointevent 右键事件
 * @returns {boolean} - true/false 是否允许当前菜单项显示
 */
window[displayCondition](menuItem, pointevent)()
```

该调用支持简单的点分链式调用、参数传递和文本替换。详细的实现逻辑请见下文。

```yaml 使用示例
- { eventName: 'readMode' } # 内部事件：切换阅读模式
- { eventName: 'window.location.reload' }  # 刷新页面
- { eventName: 'volantis.dark.toggle' } # 切换深色模式
- { eventName: 'window.open(linkAddress)' } # 新标签页打开链接
- { eventName: 'OpenSearch(selectedText)' } # 打开搜索页面，并传递当前选中文本
- { eventName: 'window.open("https://www.bing.com/search?q=##selectedText##")' } # 必应搜索
```

由于传递参数的数量不定，外部函数如有需要，建议使用 `...args` 接收参数。

```js 程序的实际调用方式
// context: 执行函数名
// functionArgs: eventName 定义时的内部已有参数
// args: menuItem, (event), pointEvent
context.apply(parentContext, functionArgs.concat(args));
```

### 1.2 页面绘制

menuItem 中的属性将以 `data-xxxx` 格式写入到菜单项的 HTML 元素上。

```html 例外属性： linkTarget ➡ target, link ➡ href
<% if(item.link === undefined) { %>
  <li class="menuLoad-Content">
    <span class="vlts-menu" data-id="<%- item.id %>" data-event-name="<%= item.eventName %>"
      data-display-condition="<%- item.displayCondition %>">
      <i class="<%- item.icon %>"></i>
      <%- item.name %>
    </span>
  </li>
<% } else { %>
  <% if(!item.linkTarget) item.linkTarget = '_self' %>
  <li class="menuLoad-Content">
    <a class="vlts-menu" data-id="<%- item.id %>" href="<%- item.link %>" 
    target="<%- item.linkTarget %>" data-display-condition="<%- item.displayCondition %>">
      <i class="<%- item.icon %>"></i>
      <%- item.name %>
    </a>
  </li>
<% } %>
```

## 二、流程设计

大致处理流程如下：

👐 使用右键选择器在页面中找到 HTML 元素。

🙌 如果找到，则读取所有导航栏和菜单项**赋值**存储。

🤲 覆盖浏览器默认的右键菜单，**绘制**菜单项并显示自定义右键菜单。

🙏 为右键菜单点击事件添加事件委托，触发相应**事件**。

🤝 Pjax 兼容**回调**。

### 2.1 赋值

```js
const menuContainer = document.querySelector(menuSelector)
const maxMenuItems = Number(menuContainer.dataset.maxMenuItems)
```

{% tabs tab-1 %}

<!-- tab 右键导航项 -->

```js
const navigationItems = Array.from(
        menuContainer.querySelectorAll('.menuNavigation-Content a'))
  .map(item => ({
    id: item.dataset.id || item.id,
    displayCondition: item.dataset.displayCondition,
    menuContentElement: item
  }));
```

<!-- endtab -->

<!-- tab 右键菜单项   -->

```js
const menuItems = Array.from(menuContainer.querySelectorAll('.menuLoad-Content'))
  .flatMap(item => {
    const elem = item.firstElementChild;
    if (elem) {
      return [{
        link: elem.href,
        id: elem.dataset.id || elem.id,
        linkTarget: elem.target || elem.dataset.linkTarget,
        eventName: elem.dataset.eventName,
        displayCondition: elem.dataset.displayCondition,
        isHrElement: elem.tagName === 'HR',
        menuContentElement: item
      }];
    }
    return [];
  });
```

<!-- endtab -->

{% endtabs %}

### 2.2 绘制

```js 简易流程展示
const conditions = {
  inInputField: () => {},
  selectedText: () => {},
  onImage: () => {},
  onLink: () => {},
  articlePage: () => {},
  scrolledFromTop: () => {},
  homePage: () => {}
};

const evaluateCondition = (menuItem, pointerEvent) => {
  if (conditions[menuItem.displayCondition]) {
    return conditions[menuItem.displayCondition](menuItem, pointerEvent);
  }
};

const showCustomContextMenu = (pointerEvent) => {
  menuItems.forEach(item => {
    if (evaluateCondition(item, pointerEvent)) {
      item.menuContentElement.classList.add('active');
    } else {
      item.menuContentElement.classList.remove('active');
    }
  })
};

const positionMenu = (pointerEvent) => {
  pointerEvent.preventDefault();
  showCustomContextMenu(pointerEvent);

  menuContainer.classList.add('active');
  menuContainer.style.left = `${posX}px`;
  menuContainer.style.top = `${posY}px`;
}

document.addEventListener('contextmenu', (pointerEvent) => {
  positionMenu(pointerEvent)
})
```

### 2.3 事件

{% codeblock lang:js 简易流程展示 %}
const eventHandlers = {
  // 预设事件
}

const handleEvent = (id, eventName, event) => {
  if (eventHandlers[eventName]) {
    eventHandlers[eventName](item, globalData.pointerEvent);
  }
};

menuContainer.addEventListener('click', event => {
  const navigation = event.target.closest('.menuNavigation-Content a'); // 导航栏
  const menuContent = event.target.closest('.menuLoad-Content span'); // 菜单项
  const targetElement = navigation || menuContent;

  if (targetElement && targetElement.dataset.eventName && targetElement.dataset.id) {
    handleEvent(targetElement.dataset.id, targetElement.dataset.eventName, event);
  }
  // else 普通链接型 无需处理
});
{% endcodeblock %}

### 2.4 回调

```js
document.addEventListener("pjax:send", hideContextMenu);
```

## 三、功能实现

完整的实现内容请见如下链接，具体分析待日后补充（{% emoji shuizhuo %}）。

{% link source/js/plugins/rightMenus.js, https://github.com/inkss/volantis/blob/clean/source/js/plugins/rightMenus.js %}